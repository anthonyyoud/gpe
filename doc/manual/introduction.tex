% $Id$
%------------------------------------------------------------------------------

\begin{chapter}{\label{cha:introduction}Introduction}
  The GPE code is a modular 3D Gross--Pitaevskii equation solver, written in
  Fortran 90 and parallelised using the Message Passing Interface (MPI).
  
  The code can solve a range of problems for both homogeneous and
  non-homogeneous (trapped) condensates, including vortex dynamics (lines,
  rings), and non-equilibrium dynamics (condensate formation).

  Time stepping is performed explicitly using one of the following methods:
  %
  \begin{itemize}
    \item first-order Euler (E1);
    \item second-order Runge--Kutta (RK2);
    \item fourth-order Runge--Kutta (RK4);
    \item fourth/fifth-order adaptive Runge--Kutta--Fehlberg (RK45).
  \end{itemize}
  %
  The spatial discretisation is performed with either second- or fourth-order
  accurate centred finite differences, and the boundary conditions can be
  either periodic or reflective.

  The ``kind'' of floating point variables is parametrised, so real or
  double-precision arithmetic can be specified without relying on compiler
  switches.

  Some publications that have used the code include \citet{AYB08} and
  \citet{WBPYW10}.

  \section{\label{sec:prelim}Preliminaries and required software}
  Since the code is parallelised using MPI, an MPI parallel environment must be
  available (currently, this is also true even when running on one processor).
  The code has been tested with the MPICH and OpenMPI implementations of MPI,
  but other implementations which adhere to the MPI standard should also be
  useable.

  The code uses some Fortran 2003 features, including allocatable arrays within
  user-defined types, the \verb"protected" keyword, and stream I/O, so a
  compiler which allows some Fortran 2003 constructs is required.  Compilers
  known to work include sunf95 (Sun Studio 12), ifort (Intel Fortran Compiler),
  and gfortran (GNU Fortran Compiler).

  The code also requires the FFTw library (\url{http://www.fftw.org}) for some
  routines.  This must be version 2 of the library (the latest is version
  2.1.5), since FFTs in the code are performed in parallel, and FFTw version 3
  does not yet support (distributed) parallel transforms.

  To view the output of the code, any graphics program capable of reading
  space-separated, columnar text files will be able to produce time-series
  plots (gnuplot is a nice, easy to use program,
  \url{http://www.gnuplot.info/}).  Routines written in IDL (Interactive Data
  Language, \url{http://www.ittvis.com/ProductServices/IDL.aspx}) for producing
  2D contour and 3D isosurface plots are included with the code.  The data for
  these plots are saved in binary format, so more work will be needed if a
  different graphics program is to be used.  Volume renderings using VAPOR
  (\url{http://www.vapor.ucar.edu/}) are also possible.

  \subsection{Summary of required hardware and software}
  The following outlines the required hardware and software needed to run the
  code.  Other hardware and software may work, but has not been tested.
  %
  \begin{itemize}
    \item A Unix-like operating system, running on x86 or x86\_64 hardware.
    \item A standard development environment including make.
    \item A Fortran 90 compiler, supporting Fortran 2003 constructs (see
      above).
    \item An implementation of MPI, \eg OpenMPI or MPICH.
    \item Version 2.x.y of the FFTw library.
    \item gnuplot and/or IDL for visualisation; VAPOR optional.
  \end{itemize}

  \subsection{\label{subsec:idl_setup}IDL}
  If you intend to use IDL to produce 2D contour and 3D isosurface plots, then
  you will need to make sure that some environment variables are set in your
  startup files, \eg \verb".cshrc" if you are using C Shell, or \verb".profile"
  if you are using Bash.  These variables are:
  %
  \begin{itemize}
    \item \verb"IDL_DIR" --- specifies the IDL install directory;
    \item \verb"IDL_PATH" --- specifies the directories in which IDL will look
      to find IDL procedures and functions;
    \item \verb"IDL_STARTUP" --- specifies where to find the IDL startup file
      \verb".idlrc".
  \end{itemize}
  %
  Two example files in the \gpefile{idl} subdirectory of the main code
  directory, named \gpefile{idl.csh} and \gpefile{idl.sh} (for C Shell
  and Bash respectively), provide example commands to set these environment
  variables.  They will likely need to be edited to suit your system, then
  added to your startup file.

  An example \verb".idlrc" file is also provided (named \gpefile{dot.idlrc}),
  which fixes some quirks with X displays, and sets 24-bit true colour output
  by default.  If you wish to use this, then make sure that the
  \verb"IDL_STARTUP" environment variable points to this file.

  \subsubsection{IDL command line}
  You might find that IDL's command line is broken, \ie no command-line
  completion, no command-line history, inability to use the \texttt{End} or
  \texttt{Home} keys, etc.  To remedy this, install the \texttt{rlwrap}
  package, and set up an alias \texttt{alias -a -c idl} for the \texttt{idl}
  command.  This will provide \texttt{readline} functionality for IDL.

  \section{Organisation of this manual}
  The rest of this manual is organised as follows:
  %
  \begin{itemize}
    \item Chapter~\ref{cha:quickstart} is a getting started guide.  The chapter
      will guide you through the basics of setting up, compiling, and running
      the code, as well as visualising some of the results.
    \item Chapter~\ref{cha:equations} describes the governing equations, and
      the non-dimensionalisation used.
    \item Chapter~\ref{cha:numerics} describes some of the numerical
      formulation, including time stepping schemes, spatial discretisation, and
      boundary conditions.
    \item Chapter~\ref{cha:file_reference} describes the files which make up
      the code, including source files, input and output files, and the IDL
      programs used for visualisation.
  \end{itemize}
\end{chapter}
