$Id$
----------------------------------------------------------------------------

DESCRIPTION
-----------
Modular Gross-Pitaevskii equation solver in 3D parallelised using MPI.  The
time stepping scheme can be either explicit second-order Euler, explicit
fourth-order Runge-Kutta, or explicit fourth-order adaptive
Runge-Kutta-Fehlberg using the algorithm proposed in Numerical Recipes (section
16.2, page 708).  The spatial discretisation is via either second-order or
fourth-order accurate centred finite differences.  The boundary conditions can
be either periodic or reflective.  A variety of initial conditions are possible
including vortex lines, vortex rings, and rarefaction pulses.  Any combination
of these is possible by simply multiplying the desired initial conditions
together.

The code uses MPI (Message Passing Interface) as the method of parallelisation
in solving the GP equation.

IMPORTANT INFORMATION
---------------------
Since the code uses MPI for the parallelism, an MPI parallel environment must
be available.  The code has only been tested with the MPICH and OpenMPI
implementations of MPI.

The code uses some Fortran 2003 features such as allocatable arrays within
user-defined types, so a compiler which allows some Fortran 2003 constructs is
required.  Compilers known to work include sunf95 (Sun Studio 12), ifort (Intel
Fortran Compiler), and gfortran (GNU Fortran Compiler).  Sunf95 with the -fast
option gives the shortest execution times.

A parallel FFT routine is included which uses the fftw library
(http://www.fftw.org).  The single precision and MPI libraries will need to be
installed and linked to as described below under the makefile heading.

PROGRAM FILES
-------------
constants.f90                   - constants defined for fftw.

derivs.f90			- Routines to calculate derivatives.

error.f90                       - Routines for error handling.

gpe.f90 			- Main program file.

ic.f90	        		- Routines to set up initial conditions.

io.f90				- Routines to do with input/output.

parameters.f90			- Parameters to set (see below).

solve.f90			- Routines to solve the equation.

variables.f90			- User-defined types and other general routines
                                  to do with variables.

OTHER FILES
-----------
Makefile			- Makefile for easy compilation.

README				- This file.

run_script*.sh			- Scripts for distributing data to the nodes
                                  of a cluster.  Will need to be customised.

setup				- Setup script which runs the Makefile to
                                  compile and set up the code ready to run in
                                  separate directory.

MAIN PARAMETERS
---------------
pp_filtered_surface (logical) - Set to false and ignore following three lines.
nlines (integer)
nfilter (integer)
fscale (real)

nyprocs (integer).  The number of processes in the y-direction.

nzprocs (integer).  The number of processes in the z-direction.

There are no restrictions on the above two parameters other than that they be
>= 1.  In general, it is recommended that nzprocs>=nyprocs for best performance
so that fewer non-contiguous data transfers are performed.  They can both be
set to 1 in which case the job is simply run on one process (an MPI parallel
environment is still required though).

nx (integer) - Number of grid points in the x-direction.

ny (integer) - Number of grid points in the y-direction.

nz (integer) - Number of grid points in the z-direction.

tau (real) - The initial timestep to try.  Valid for both imaginary and real
             time.  See real_time (logical) below.

end_time (real) - The final (dimensionless) time.

xr (real) - The x-coordinate of the right-hand-side of the computational box
            (the left-hand-side is set to -xr).

yr (real) - As above but for the y-coordinate.

zr (real) - As above but for the z-coordinate.

Urhs (real) - Set non-zero to solve the equation in a moving
              reference frame.

diss_amp (real) - Set non-zero to include dissipation of this amplitude at the
                  boundaries.

scal (real) - Set non-zero to scale vortex rings/lines.

nv (real) - For random phase approximation, the total mass per unit volume.

enerv (real) - For random phase approximation, the total kinetic energy per
               unit volume.

eqn_to_solve (integer) - The form of the GPE to solve.  See subroutine
                         get_rhs() in solve.f90 to see the options.

bcs (integer) - The boundary conditions to use.  Set to 1 for periodic BCs; set
                to 2 for reflective BCs.

order (integer) - The order of the derivatives to use.  Set to 2 for
                  second-order; set to 4 for fourth-order.

save_rate (integer) - The rate at which time-series data should be saved
                      (roughly corresponding to the number of time steps).

save_rate2 (real) - How often (in terms of actual time units) isosurface data
                    should be saved (3D isosurfaces, 2D surfaces).

save_rate3 (real) - How often (in terms of actual time units) data to do with
                    condensed particles and PDFs should be saved.

p_save (real) - How often (in terms of actual time units) the code should save
                its own state, so that it can be restarted in the event of a
                machine failure, etc.

save_contour (logical) - Should 2D contour data be saved?

save_3d (logical) -  Should 3D isosurface data be saved?

save_filter (logical) - Should 3D filtered isosurfaces of the density be saved?

save_average (logical) - Should 3D time-averaged isosurfaces of the density be
                         saved?

save_spectrum (logical) - Should various spectra be saved (mainly for random
                          phase approximation).

save_pdf (logical) - Should PDFs of the velocity components be saved?

save_ll (logical) - Should the vortex line length be saved?

save_zeros (logical) - Should the points of zero density be saved (not
                       reliable!)?

restart (logical) - Is this run going to be a restart of a previous run?  If
                    so, then the file end_state.dat in each process directory
                    should be copied to the restart directory named
                    end_state00.dat, end_state01.dat, end_state02.dat, etc.

saved_restart (logical) - Set true if using filtered data from a previous run
                          to multiply with the initial condition of a new run.

real_time (logical) - Should the run be started in real time or not?

diagnostic (logical) - Calculate diagnostics?

scheme (character) - The time stepping scheme to use.  This must be set to one
                     of:
                       euler       - for explicit second-order Euler time
                                     stepping
                       rk4         - for explicit fourth-order Runge-Kutta time
                                     stepping
                       rk_adaptive - for explicit adaptive fourth-order
                                     Runge-Kutta-Fehlberg time stepping.

eps (real) -  The factor by which the fourth-order RK scheme must be close to
              the fifth-order RKF scheme.  This determines whether a time step
              has been successful and hence whether to increase or decrease the
              time step for the next step.

safety (real)
dt_decrease (real) - See the Numerical Recipes algorithm for these three.
dt_increase (real)

Two types are also defined in the parameters file in order to set up a vortex
line or vortex ring.  Comments for how to set these up are in parameters.f90.

Other parameters not mentioned here can be left as they are.

run_script*.sh
-------------
Example bash scripts which give examples of how a job might be submitted to a
batch queue system (such as Torque, SGE or Condor) or how data might be
distributed across the nodes of a cluster.

Makefile
--------
Settings here will need to be changed, depending on the architecture on which
the code is run.

OBJECT    - The name of the executable produced on compilation.

OBJECTS   - The object files that should be linked.

FC        - The Fortran compiler to be used.  Could be the MPI wrapper
            compiler mpif90, but the underlying Fortran compiler must be
            able to compile the code (e.g. sunf95, ifort, gfortran).

FFLAGS    - Compiler flags.  See the compiler's manual.  Sunf95 works well with
            -fast.  If nonsense results are produced -fsimple=0 might be
            required.

LDFLAGS   - Any extra flags required by the linker.  If mpif90 is not the
            compiler, then all the MPI libraries will need to be linked.
            The FFTW libraries need to be linked here too.

INCLUDE   - Include path (i.e. for MPI header files).

TO RUN
------
Set the parameters in parameters.f90.  Initial conditions need to be set in
ic.f90.  Then run

  ./setup <directory>

which compiles the code, copies parameters.f90 (and possibly a run_script.sh
file) and moves OBJECT to <directory>.

Then change to <directory> and use mpiexec to run the code, e.g.

  nohup mpiexec -n nprocs ./gpe > stdout &

where nprocs is the number of processes and nohup ensures logging out of the
machine does not hang the job.

If restarting from a previous run then be sure to set restart=.true. in
parameters.f90.  Copy the file 'end_state.dat' from the process directories
of the preceding run to the restart directory and rename them end_state00.dat,
end_state01.dat, etc.

Errors are output if either:
1) end_state??.dat exists but restart=.false. or
2) restart=.true. but end_state??.dat does not exist.

Any run should be cleanly stopped by removing the empty file 'RUNNING' which is
present in the run directory once the job has started.  This avoids having to
use Ctrl-C to interrupt the program.  Using this procedure will ensure that all
run-time files are cleaned up and unneeded directories removed.

OUTPUT FILES
------------
energy.dat      - Saves the energy at each time.

linelength.dat  - Saves the total line length of vortices in the condensate.

mass.dat        - Saves the mass at each time.

minmax_*.dat    - Saves the minimum and maximum of the density, filtered
                  density and time-averaged density over the duration of the
                  run.

norm.dat        - Saves the norm at each time.

misc.dat        - Any miscellaneous data can be sent to this file.

momentum.dat    - Saves the three components of the momentum.

p_saved.dat     - The values of the time index p when the code saved its own
                  state.

save.dat        - The parameters for the most recently saved state.

timestep.dat    - The imaginary and real time step at each time.

u_time.dat      - Saves the real and imaginary time, the real and imaginary
                  parts of the wavefunction, the density, and the phase.

proc**          - Numbered directories corresponding to each process involved
                  in the run.  Each of these directories contains the following
                  files:
                  end_state.dat         - The saved state of the run.

                  im_zeros*******.dat   - The coordinates where the imaginary
                                          part of the wavefunction goes to
                                          zero.

                  re_zeros*******.dat   - The coordinates where the real part
                                          of the wavefunction goes to zero.

                  dens*******.dat       - If 3D isosurfaces were requested,
                                          they are saved in these files.

                  filtered*******.dat   - As above but for filtered data.

                  ave*******.dat        - As above but for time-averaged data.

                  spectrum*******.dat   - The spectrum (n_k vs. k).

                  zeros*******.dat      - The coordinates where the real and
                                          imaginary parts of the wavefunction
                                          simultaneously go to zero.

                  In addition, if 2D contour plots were requested then, some of
                  the process directories will contain files named
                  u*******.dat.  These are the processes on which the 2D plane
                  occurred.

10/11/2009
