$Id$
----------------------------------------------------------------------------

DESCRIPTION
-----------
Modular Gross-Pitaevskii equation solver in 3D parallelised using MPI.  The
time stepping scheme can be either explicit second-order Euler, explicit
fourth-order Runge-Kutta, or explicit fourth-order adaptive
Runge-Kutta-Fehlberg using the algorithm proposed in Numerical Recipes (section
16.2, page 708).  The spatial discretisation is via either second-order or
fourth-order accurate centred finite differences.  The boundary conditions can
be either periodic or reflective.  A variety of initial conditions are possible
including vortex lines, vortex rings, and rarefaction pulses.  Any combination
of these is possible by simply multiplying the desired initial conditions
together.

The code uses MPI (Message Passing Interface) as the method of parallelisation
in solving the GP equation.

IMPORTANT INFORMATION
---------------------
Since the code uses MPI for the parallelism, an MPI parallel environment must
be available.  The code has only been tested with the MPICH and OpenMPI
implementations of MPI.

The code uses some Fortran 2003 features such as allocatable arrays within
user-defined types, so a compiler which allows some Fortran 2003 constructs is
required.  Compilers known to work include sunf95 (Sun Studio 12), ifort (Intel
Fortran Compiler), and gfortran (GNU Fortran Compiler).  Sunf95 with the -fast
option gives the shortest execution times.

A parallel FFT routine is included which uses the fftw library
(http://www.fftw.org).  The single precision and MPI libraries will need to be
installed and linked to as described below under the makefile heading.

PROGRAM FILES
-------------
constants.f90  - constants defined for fftw.

derivs.f90		 - Routines to calculate derivatives.

error.f90      - Routines for error handling.

gpe.f90 			 - Main program file.

ic.f90	       - Routines to set up initial conditions.

ic.in          - User-defined initial condition.

io.f90				 - Routines to do with input/output.

parameters.f90 - Parameters and global variables.

parameters.in  - Parameters to set which require code recompilation (see below).

run.in         - Parameters to set which do not require code recompilation.

solve.f90			 - Routines to solve the equation.

variables.f90	 - User-defined types and other general routines to do with
                 variables.

OTHER FILES
-----------
Makefile			 - Makefile for easy compilation.

README				 - This file.

run_script*.sh - Scripts for distributing data to the nodes of a cluster.
                 Will need to be customised.

setup				   - Setup script which runs the Makefile to compile and set up the
                 code ready to run in separate directory.

PARAMETERS TO SET (parameters.in)
---------------------------------
NOTE: Any changes to this file will require a code recompilation.

pr (integer) - The precision of real variables is parametrised.  Choose the
               desired line for either real or double precision.

nyprocs (integer) - The number of processes in the y-direction.

nzprocs (integer) - The number of processes in the z-direction.

There are no restrictions on the above two parameters other than that they be
>= 1.  In general, it is recommended that nzprocs>=nyprocs for best performance
so that fewer non-contiguous data transfers are performed.  They can both be
set to 1 in which case the job is simply run on one process (an MPI parallel
environment is still required though).

nx (integer) - Number of grid points in the x-direction.

ny (integer) - Number of grid points in the y-direction.

nz (integer) - Number of grid points in the z-direction.

Two types are also defined in parameters.in in order to set up a vortex line or
vortex ring.  See the comments in the file itself for how to set these up.

PARAMETERS TO SET (run.in)
--------------------------
NOTE: Any changes to this file will not require a code recompilation.

tau (real) - The initial timestep to try.  Valid for both imaginary and real
             time.  See real_time (logical) below.

end_time (real) - The final (dimensionless) time.

xr (real) - The x-coordinate of the right-hand-side of the computational box
            (the left-hand-side is set to -xr).

yr (real) - As above but for the y-coordinate.

zr (real) - As above but for the z-coordinate.

scheme (character) - The time stepping scheme to use.  This must be set to one
                     of:
                       euler       - for explicit second-order Euler time
                                     stepping
                       rk2         - for explicit second-order Runge-Kutta time
                                     stepping
                       rk4         - for explicit fourth-order Runge-Kutta time
                                     stepping
                       rk45        - for explicit adaptive fourth-order
                                     Runge-Kutta-Fehlberg time stepping.

eqn_to_solve (integer) - The form of the GPE to solve.  See subroutine
                         get_rhs() in solve.f90 to see the options.

bcs (integer) - The boundary conditions to use.  Set to 1 for periodic BCs; set
                to 2 for reflective BCs.

order (integer) - The order of the derivatives to use.  Set to 2 for
                  second-order; set to 4 for fourth-order.

restart (logical) - Is this run going to be a restart of a previous run?  If
                    so, then the file end_state.dat in each process directory
                    should be copied to the restart directory named
                    end_state00.dat, end_state01.dat, end_state02.dat, etc.
                    The script run.sh will do this automatically.

saved_restart (logical) - Set true if using filtered data from a previous run
                          to multiply with the initial condition of a new run.

renorm (logical) - Set true if the wavefunction should be renormalised at
                   every time step in imaginary time.

imprint_vl (logical) - Set true if the wavefunction should be multiplied by a
                       vortex line at each time step in imaginary time.

stop_imag (logical) - Set true if the run should stop at the end of imaginary
                      time, i.e. when the norms of successive time steps are
                      deemed to be sufficiently small.

real_time (logical) - Should the run be started in real time or not?

Urhs (real) - Set non-zero to solve the equation in a moving reference frame.

diss_amp (real) - Set non-zero to include dissipation of this amplitude at the
                  boundaries.

scal (real) - Set non-zero to scale vortex rings/lines.

nv (real) - For random phase approximation, the total mass per unit volume.

enerv (real) - For random phase approximation, the total kinetic energy per
               unit volume.

g (real) - Interaction parameter for trapped condensate.

mu (real) - Chemical potential for trapped condensate.

nn (real) - Number of atoms in a trapped condensate.  Should currently be left
            to 1.0, and instead tune mu and g to specify nn.

omx (real) - Frequency of trap in x-direction.

omy (real) - Frequency of trap in y-direction.

omz (real) - Frequency of trap in z-direction.

save_rate (integer) - The rate at which time-series data should be saved
                      (roughly corresponding to the number of time steps).

save_rate2 (real) - How often (in terms of actual time units) isosurface data
                    should be saved (3D isosurfaces, 2D surfaces).

save_rate3 (real) - How often (in terms of actual time units) data to do with
                    condensed particles and PDFs should be saved.

p_save (real) - How often (in terms of actual time units) the code should save
                its own state, so that it can be restarted in the event of a
                machine failure, etc.

save_contour (logical) - Should 2D contour data be saved?

save_3d (logical) -  Should 3D isosurface data be saved?

save_filter (logical) - Should 3D filtered isosurfaces of the density be saved?

filter_kc (real) - The cutoff wavenumber used to filter the isosurfaces.

save_average (logical) - Should 3D time-averaged isosurfaces of the density be
                         saved?

save_spectrum (logical) - Should various spectra be saved (mainly for random
                          phase approximation).

save_pdf (logical) - Should PDFs of the velocity components be saved?

save_vcf (logical) - Should the velocity correlation function be saved?

save_ll (logical) - Should the vortex line length be saved?

save_zeros (logical) - Should the points of zero density be saved (not
                       reliable!)?

Other parameters not mentioned here can be left as they are.

INITIAL CONDITION (ic.in)
-------------------------
Due to the multitude of possible initial conditions it would not be feasible to
provide a simple switch to choose the initial condition.  Instead, the initial
condition should be defined in this file, in the form init_cond =
some_function.  See the file itself for examples.  The file is included
directly in ic.f90, so should be written with correct Fortran syntax.

run_script*.sh
--------------
Example bash scripts which give examples of how a job might be submitted to a
batch queue system (such as Torque, SGE or Condor) or how data might be
distributed across the nodes of a cluster.

run.sh
------
For shared memory multiple-CPU machines, this script will set up and run the
code from a run directory.  Run it with no arguments to see the help.

Makefile
--------
Settings here will need to be changed, depending on the architecture on which
the code is run.

OBJECT - The name of the executable produced on compilation.

OBJS - The object files that should be linked.

FC - The Fortran compiler to be used.  Could be the MPI wrapper compiler
     mpif90, but the underlying Fortran compiler must be able to compile the
     code (e.g. sunf95, ifort, gfortran).

FFLAGS - Compiler flags.  See the compiler's manual.  Sunf95 works well with
         -fast.  If nonsense results are produced -fsimple=0 might be required.

LDFFTW - FFTw libraries to link.  Compiling with make precision=single will
         link the single precision libraries.

LDFLAGS - Any extra flags required by the linker.  If mpif90 is not the
          compiler, then all the MPI libraries will need to be linked.

INCLUDE - Include path (i.e. for MPI header files).

TO RUN
------
Set the parameters and initial condition by editing parameters.in, ic.in, and
run.in.  Then run

  ./setup <directory>

which compiles the code, copies parameters.in, ic.in, run.in, run.sh (and
possibly a run_script.sh file) and moves OBJECT to <directory>.

Then change to <directory> and use run.sh to run the code, e.g.

  ./run.sh nprocs

where nprocs is the number of processes.  Logging out of the machine will not
hang the job.

If restarting from a previous run then be sure to set restart=.true. in
run.in.  Make sure run.in and parameters.in are copied to the restart
directory.

Copy the file 'end_state.dat' from the process directories of the preceding run
to the restart directory and rename them end_state00.dat, end_state01.dat, etc.
If using run.sh, then this last step is done automatically provided the -r
option is given.

Errors are output if either:
1) end_state??.dat exists but restart=.false. or
2) restart=.true. but end_state??.dat does not exist.

Any run should be cleanly stopped by removing the empty file 'RUNNING' which is
present in the run directory once the job has started.  This avoids having to
use Ctrl-C to interrupt the program.  Using this procedure will ensure that all
run-time files are cleaned up and unneeded directories removed.

OUTPUT FILES
------------
energy.dat      - Saves the energy at each time.

linelength.dat  - Saves the total line length of vortices in the condensate.

mass.dat        - Saves the mass at each time.

minmax_*.dat    - Saves the minimum and maximum of the density, filtered
                  density and time-averaged density over the duration of the
                  run.

norm.dat        - Saves the norm at each time.

misc.dat        - Any miscellaneous data can be sent to this file.

momentum.dat    - Saves the three components of the momentum.

p_saved.dat     - The values of the time index p when the code saved its own
                  state.

save.dat        - The parameters for the most recently saved state.

timestep.dat    - The imaginary and real time step at each time.

u_time.dat      - Saves the real and imaginary time, the real and imaginary
                  parts of the wavefunction, the density, and the phase.

proc**          - Numbered directories corresponding to each process involved
                  in the run.  Each of these directories contains the following
                  files:
                  end_state.dat         - The saved state of the run.

                  im_zeros*******.dat   - The coordinates where the imaginary
                                          part of the wavefunction goes to
                                          zero.

                  re_zeros*******.dat   - The coordinates where the real part
                                          of the wavefunction goes to zero.

                  dens*******.dat       - If 3D isosurfaces were requested,
                                          they are saved in these files.

                  filtered*******.dat   - As above but for filtered data.

                  ave*******.dat        - As above but for time-averaged data.

                  spectrum*******.dat   - The spectrum (n_k vs. k).

                  zeros*******.dat      - The coordinates where the real and
                                          imaginary parts of the wavefunction
                                          simultaneously go to zero.

                  In addition, if 2D contour plots were requested then, some of
                  the process directories will contain files named
                  u*******.dat.  These are the processes on which the 2D plane
                  occurred.

                  The 3D isosurface data can be requested at any time by
                  creating an empty file named SAVE in the run directory.  Once
                  the data are saved, this empty file is removed.

AJY 15/06/2010
